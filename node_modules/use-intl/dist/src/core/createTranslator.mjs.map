{"version":3,"sources":["../../../src/core/createTranslator.tsx"],"sourcesContent":["import Formats from './Formats';\nimport IntlConfig from './IntlConfig';\nimport TranslationValues from './TranslationValues';\nimport createTranslatorImpl, {\n  CoreRichTranslationValues\n} from './createTranslatorImpl';\nimport {defaultGetMessageFallback, defaultOnError} from './defaults';\nimport MessageKeys from './utils/MessageKeys';\nimport NamespaceKeys from './utils/NamespaceKeys';\nimport NestedKeyOf from './utils/NestedKeyOf';\nimport NestedValueOf from './utils/NestedValueOf';\n\n/**\n * Translates messages from the given namespace by using the ICU syntax.\n * See https://formatjs.io/docs/core-concepts/icu-syntax.\n *\n * If no namespace is provided, all available messages are returned.\n * The namespace can also indicate nesting by using a dot\n * (e.g. `namespace.Component`).\n */\nexport default function createTranslator<\n  NestedKey extends NamespaceKeys<\n    IntlMessages,\n    NestedKeyOf<IntlMessages>\n  > = never\n>({\n  getMessageFallback = defaultGetMessageFallback,\n  messages,\n  namespace,\n  onError = defaultOnError,\n  ...rest\n}: Omit<IntlConfig<IntlMessages>, 'defaultTranslationValues' | 'messages'> & {\n  messages: NonNullable<IntlConfig<IntlMessages>['messages']>;\n  namespace?: NestedKey;\n}): // Explicitly defining the return type is necessary as TypeScript would get it wrong\n{\n  // Default invocation\n  <\n    TargetKey extends MessageKeys<\n      NestedValueOf<\n        {'!': IntlMessages},\n        [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n      >,\n      NestedKeyOf<\n        NestedValueOf<\n          {'!': IntlMessages},\n          [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n        >\n      >\n    >\n  >(\n    key: TargetKey,\n    values?: TranslationValues,\n    formats?: Partial<Formats>\n  ): string;\n\n  // `rich`\n  rich<\n    TargetKey extends MessageKeys<\n      NestedValueOf<\n        {'!': IntlMessages},\n        [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n      >,\n      NestedKeyOf<\n        NestedValueOf<\n          {'!': IntlMessages},\n          [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n        >\n      >\n    >\n  >(\n    key: TargetKey,\n    values?: CoreRichTranslationValues,\n    formats?: Partial<Formats>\n  ): string;\n\n  // `raw`\n  raw<\n    TargetKey extends MessageKeys<\n      NestedValueOf<\n        {'!': IntlMessages},\n        [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n      >,\n      NestedKeyOf<\n        NestedValueOf<\n          {'!': IntlMessages},\n          [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n        >\n      >\n    >\n  >(\n    key: TargetKey\n  ): any;\n} {\n  // We have to wrap the actual function so the type inference for the optional\n  // namespace works correctly. See https://stackoverflow.com/a/71529575/343045\n  // The prefix (\"!\") is arbitrary.\n  return createTranslatorImpl<\n    {'!': IntlMessages},\n    [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n  >(\n    {\n      ...rest,\n      onError,\n      getMessageFallback,\n      messages: {'!': messages},\n      // @ts-ignore\n      namespace: namespace ? `!.${namespace}` : '!'\n    },\n    '!'\n  );\n}\n"],"mappings":"AAGA,OAAOA,MAEA,yBACP,OAAQ,6BAAAC,EAA2B,kBAAAC,MAAqB,aAczC,SAARC,EAKL,CACA,mBAAAC,EAAqBH,EACrB,SAAAI,EACA,UAAAC,EACA,QAAAC,EAAUL,EACV,GAAGM,CACL,EA8DE,CAIA,OAAOR,EAIL,CACE,GAAGQ,EACH,QAAAD,EACA,mBAAAH,EACA,SAAU,CAAC,IAAKC,CAAQ,EAExB,UAAWC,EAAY,KAAKA,CAAS,GAAK,GAC5C,EACA,GACF,CACF","names":["createTranslatorImpl","defaultGetMessageFallback","defaultOnError","createTranslator","getMessageFallback","messages","namespace","onError","rest"]}