{"version":3,"sources":["../../src/core/createTranslatorImpl.tsx"],"sourcesContent":["import AbstractIntlMessages from './AbstractIntlMessages';\nimport {InitializedIntlConfig} from './IntlConfig';\nimport IntlError, {IntlErrorCode} from './IntlError';\nimport {RichTranslationValues, TranslationValue} from './TranslationValues';\nimport createBaseTranslator, {getMessagesOrError} from './createBaseTranslator';\nimport resolveNamespace from './resolveNamespace';\nimport NestedKeyOf from './utils/NestedKeyOf';\n\nexport type CoreRichTranslationValues = Record<\n  string,\n  TranslationValue | ((chunks: string) => string)\n>;\n\nexport type CreateTranslatorImplProps<Messages> = Omit<\n  InitializedIntlConfig,\n  'messages'\n> & {\n  namespace: string;\n  messages: Messages;\n};\n\nexport default function createTranslatorImpl<\n  Messages extends AbstractIntlMessages,\n  NestedKey extends NestedKeyOf<Messages>\n>(\n  {\n    getMessageFallback,\n    messages,\n    namespace,\n    onError,\n    ...rest\n  }: CreateTranslatorImplProps<Messages>,\n  namespacePrefix: string\n) {\n  // The `namespacePrefix` is part of the type system.\n  // See the comment in the function invocation.\n  messages = messages[namespacePrefix] as Messages;\n  namespace = resolveNamespace(namespace, namespacePrefix) as NestedKey;\n\n  const translator = createBaseTranslator<Messages, NestedKey>({\n    ...rest,\n    onError,\n    getMessageFallback,\n    messagesOrError: getMessagesOrError({\n      messages,\n      namespace,\n      onError\n    }) as Messages | IntlError\n  });\n\n  const originalRich = translator.rich;\n\n  function base(...args: Parameters<typeof translator>) {\n    return translator(...args);\n  }\n\n  // Augment `t.rich` to return plain strings\n  base.rich = (\n    key: Parameters<typeof originalRich>[0],\n    /** Key value pairs for values to interpolate into the message. */\n    values: CoreRichTranslationValues,\n    formats?: Parameters<typeof originalRich>[2]\n  ): string => {\n    // `chunks` is returned as a string when no React element\n    // is used, therefore it's safe to cast this type.\n    const result = originalRich(key, values as RichTranslationValues, formats);\n\n    // When only string chunks are provided to the parser, only strings should be returned here.\n    if (typeof result !== 'string') {\n      const error = new IntlError(\n        IntlErrorCode.FORMATTING_ERROR,\n        process.env.NODE_ENV !== 'production'\n          ? \"`createTranslator` only accepts functions for rich text formatting that receive and return strings.\\n\\nE.g. t.rich('rich', {b: (chunks) => `<b>${chunks}</b>`})\"\n          : undefined\n      );\n\n      onError(error);\n      return getMessageFallback({error, key, namespace});\n    }\n\n    return result;\n  };\n\n  base.raw = translator.raw;\n\n  return base;\n}\n"],"mappings":"AAEA,OAAOA,GAAY,iBAAAC,MAAoB,cAEvC,OAAOC,GAAuB,sBAAAC,MAAyB,yBACvD,OAAOC,MAAsB,qBAgBd,SAARC,EAIL,CACE,mBAAAC,EACA,SAAAC,EACA,UAAAC,EACA,QAAAC,EACA,GAAGC,CACL,EACAC,EACA,CAGAJ,EAAWA,EAASI,CAAe,EACnCH,EAAYJ,EAAiBI,EAAWG,CAAe,EAEvD,MAAMC,EAAaV,EAA0C,CAC3D,GAAGQ,EACH,QAAAD,EACA,mBAAAH,EACA,gBAAiBH,EAAmB,CAClC,SAAAI,EACA,UAAAC,EACA,QAAAC,CACF,CAAC,CACH,CAAC,EAEKI,EAAeD,EAAW,KAEhC,SAASE,KAAQC,EAAqC,CACpD,OAAOH,EAAW,GAAGG,CAAI,CAC3B,CAGA,OAAAD,EAAK,KAAO,CACVE,EAEAC,EACAC,IACW,CAGX,MAAMC,EAASN,EAAaG,EAAKC,EAAiCC,CAAO,EAGzE,GAAI,OAAOC,GAAW,SAAU,CAC9B,MAAMC,EAAQ,IAAIpB,EAChBC,EAAc,iBACd,QAAQ,IAAI,WAAa,aACrB,kKACA,MACN,EAEA,OAAAQ,EAAQW,CAAK,EACNd,EAAmB,CAAC,MAAAc,EAAO,IAAAJ,EAAK,UAAAR,CAAS,CAAC,CACnD,CAEA,OAAOW,CACT,EAEAL,EAAK,IAAMF,EAAW,IAEfE,CACT","names":["IntlError","IntlErrorCode","createBaseTranslator","getMessagesOrError","resolveNamespace","createTranslatorImpl","getMessageFallback","messages","namespace","onError","rest","namespacePrefix","translator","originalRich","base","args","key","values","formats","result","error"]}