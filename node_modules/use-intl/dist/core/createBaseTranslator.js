"use strict";var b=Object.create;var M=Object.defineProperty;var x=Object.getOwnPropertyDescriptor;var D=Object.getOwnPropertyNames;var G=Object.getPrototypeOf,K=Object.prototype.hasOwnProperty;var F=(r,e)=>{for(var s in e)M(r,s,{get:e[s],enumerable:!0})},R=(r,e,s,a)=>{if(e&&typeof e=="object"||typeof e=="function")for(let t of D(e))!K.call(r,t)&&t!==s&&M(r,t,{get:()=>e[t],enumerable:!(a=x(e,t))||a.enumerable});return r};var v=(r,e,s)=>(s=r!=null?b(G(r)):{},R(e||!r||!r.__esModule?M(s,"default",{value:r,enumerable:!0}):s,r)),C=r=>R(M({},"__esModule",{value:!0}),r);var U={};F(U,{default:()=>_,getMessagesOrError:()=>j});module.exports=C(U);var w=v(require("intl-messageformat")),p=require("react"),f=v(require("./IntlError")),O=v(require("./convertFormatsToIntlMessageFormat")),V=require("./defaults");function T(r,e,s){if(!r)throw new Error(process.env.NODE_ENV!=="production"?`No messages available at \`${s}\`.`:void 0);let a=r;return e.split(".").forEach(t=>{const u=a[t];if(t==null||u==null)throw new Error(process.env.NODE_ENV!=="production"?`Could not resolve \`${e}\` in ${s?`\`${s}\``:"messages"}.`:void 0);a=u}),a}function P(r){if(Object.keys(r).length===0)return;const e={};return Object.keys(r).forEach(s=>{let a=0;const t=r[s];let u;typeof t=="function"?u=i=>{const E=t(i);return(0,p.isValidElement)(E)?(0,p.cloneElement)(E,{key:s+a++}):E}:u=t,e[s]=u}),e}function j({messages:r,namespace:e,onError:s=V.defaultOnError}){try{if(!r)throw new Error(process.env.NODE_ENV!=="production"?"No messages were configured on the provider.":void 0);const a=e?T(r,e):r;if(!a)throw new Error(process.env.NODE_ENV!=="production"?`No messages for namespace \`${e}\` found.`:void 0);return a}catch(a){const t=new f.default(f.IntlErrorCode.MISSING_MESSAGE,a.message);return s(t),t}}function _({cachedFormatsByLocale:r,defaultTranslationValues:e,formats:s,getMessageFallback:a=V.defaultGetMessageFallback,locale:t,messagesOrError:u,namespace:i,onError:E,timeZone:$}){function c(n,l,d){const g=new f.default(l,d);return E(g),a({error:g,key:n,namespace:i})}function y(n,l,d){if(u instanceof f.default)return a({error:u,key:n,namespace:i});const g=u;let m;try{m=T(g,n,i)}catch(o){return c(n,f.IntlErrorCode.MISSING_MESSAGE,o.message)}function A(o){return o.filter(N=>N!=null).join(".")}const S=A([i,n,String(m)]);let I;if(r?.[t]?.[S])I=r?.[t][S];else{if(typeof m=="object"){let o,N;return Array.isArray(m)?(o=f.IntlErrorCode.INVALID_MESSAGE,process.env.NODE_ENV!=="production"&&(N=`Message at \`${A([i,n])}\` resolved to an array, but only strings are supported. See https://next-intl-docs.vercel.app/docs/usage/messages#arrays-of-messages`)):(o=f.IntlErrorCode.INSUFFICIENT_PATH,process.env.NODE_ENV!=="production"&&(N=`Message at \`${A([i,n])}\` resolved to an object, but only strings are supported. Use a \`.\` to retrieve nested messages. See https://next-intl-docs.vercel.app/docs/usage/messages#structuring-messages`)),c(n,o,N)}try{I=new w.default(m,t,(0,O.default)({...s,...d},$))}catch(o){return c(n,f.IntlErrorCode.INVALID_MESSAGE,o.message)}r&&(r[t]||(r[t]={}),r[t][S]=I)}try{const o=I.format(P({...e,...l}));if(o==null)throw new Error(process.env.NODE_ENV!=="production"?`Unable to format \`${n}\` in ${i?`namespace \`${i}\``:"messages"}`:void 0);return(0,p.isValidElement)(o)||Array.isArray(o)||typeof o=="string"?o:String(o)}catch(o){return c(n,f.IntlErrorCode.FORMATTING_ERROR,o.message)}}function h(n,l,d){const g=y(n,l,d);return typeof g!="string"?c(n,f.IntlErrorCode.INVALID_MESSAGE,process.env.NODE_ENV!=="production"?`The message \`${n}\` in ${i?`namespace \`${i}\``:"messages"} didn't resolve to a string. If you want to format rich text, use \`t.rich\` instead.`:void 0):g}return h.rich=y,h.raw=n=>{if(u instanceof f.default)return a({error:u,key:n,namespace:i});const l=u;try{return T(l,n,i)}catch(d){return c(n,f.IntlErrorCode.MISSING_MESSAGE,d.message)}},h}0&&(module.exports={getMessagesOrError});
//# sourceMappingURL=createBaseTranslator.js.map